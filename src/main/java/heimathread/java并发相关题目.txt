######################---多线程---#########################
1.	java中有几种方法可以实现一个线程？   

答：在Java中实现一个线程有两种方法，第一是实现Runnable接口实现它的run（）方法，第二种是继承Thread类，覆盖它的run（）方法。
这两种方法的区别是，如果你的类已经继承了其它的类，那么你只能选择实现Runnable接口了，因为Java只允许单继承的。
要指定线程的名称  new Thread("threadName"){public void run(){}} 或者  new Thread(new Runnable(){public void run(){}},"threadName"){}


一个线程的五种状态是:新建(New)  可运行(Runnable) 阻塞状态(Blocked) 等待(Waitting) 结束(Terminated)
一个线程的运行时间分为三个部分: T1:线程启动时间   T2:线程体运行时间     T3:线程销毁时间   如果一个线程不能被重复调用 那么每次运行都会经过这三个过程
                            T2是无法避免的 只能通过优化程序来节省时间  T1和T3可以通过线程池来解决
                            

2.	如何停止一个正在运行的线程？
答: 首先不能使用 Thread.stop()来停止一个线程  原因有三:该方法已经被废弃,该方法会导致代码逻辑不完整,该方法会破坏原子逻辑.
自然如果使用的是ThreadPoolExecutor,则可以直接调用其shutDown逐步的关闭
没有使用ThreadPoolExecutor的话 可以通过一个标记位来实现  如:
class SafeStopThread extends Thread{
	private volatile boolean stop = false; // 此处一定要加修饰符 volatile
	public void run(){
		// 判断线程体是否运行
		while(stop){
			//dosomething
		}
	}
	// 终止线程
	public void terminate(){
		stop = true;
	}
}

interrupt不能终止一个线程吗? 虽然其名字看上去像是一个终止线程的方法,其实不是.它不能终止一个正在运行的线程,它只是修改中断标志
所以我们在调用线程的 Thread.interrupt()后 要自行的判断下 如:
class SafeStopThread extends Thread{
	private volatile boolean stop = false; // 此处一定要加修饰符 volatile
	public void run(){
		// 判断线程体是否运行
		while(!isInterrupted()){
			//dosomething
		}
	}
}



3.	notify()和notifyAll()有什么区别？
答： 1）notify()和notifyAll()都是Object对象用于通知处在等待该对象的线程的方法。
    2）void notify(): 唤醒一个正在等待该对象的线程。
    3）void notifyAll(): 唤醒所有正在等待该对象的线程。
        两者的最大区别在于：
         notifyAll使所有原来在该对象上等待被notify的线程统统退出wait的状态，变成等待该对象上的锁，一旦该对象被解锁，他们就会去竞争。
         notify他只是选择一个wait状态线程进行通知，并使它获得该对象上的锁，但不惊动其他同样在等待被该对象notify的线程们，
                     当第一个线程运 行完毕以后释放对象上的锁，此时如果该对象没有再次使用notify语句，即便该对象已经空闲，其他wait状态等待的线程由于没有得到该对象的
                      通知，继续处在wait状态，直到这个对象发出一个notify或notifyAll，它们等待的是被notify或notifyAll，而不是锁。
                      
                      
                      
4.	sleep()和 wait()有什么区别?
答：sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。
    wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才
	进入对象锁定池准备获得对象锁进入运行状态。
	
	
	
	
5.	什么是Daemon线程？它有什么意义？
答：所谓后台(daemon)线程，是指在程序运行的时候在后台提供一种通用服务的线程，并且这个线程并不属于程序中不可或缺的部分。因此，当所有的非后台线程介绍时，
       程序也就终止了，同时会杀死进程中的所有后台线程。反过来说，只要有任何非后台线程还在运行，程序就不会终止。必须在线程启动之前调用setDaemon()方法，
       才能把它设置为后台线程。注意：后台进程在不执行finally子句的情况下就会终止其run()方法。
       
       
       
6.	java如何实现多线程之间的通讯和协作？
答： Java提供了3个非常重要的方法来巧妙地解决线程间的通信问题。这3个方法分别是：wait()、notify()和notifyAll()。它们都是Object类的最终方法，
        因此每一个类都默认拥有它们。虽然所有的类都默认拥有这3个方法，但是只有在synchronized关键字作用的范围内，并且是同一个同步问题中搭配使用这3个方法时
        才有实际的意义。这些方法在Object类中声明的语法格式如下所示：
    final void wait() throws InterruptedException
	final void notify()
	final void notifyAll()
	




##################---锁---##################
                           
1.	什么是可重入锁（ReentrantLock）？ 
答：  java.util.concurrent.lock 中的 Lock 框架是锁定的一个抽象，它允许把锁定的实现作为 Java 类，而不是作为语言的特性来实现。这就为 Lock 的多种实现留下了空间，
          各种实现可能有不同的调度算法、性能特性或者锁定语义。 ReentrantLock 类实现了 Lock ，它拥有与 synchronized 相同的并发性和内存语义，但是添加了类似锁投票、
          定时锁等候和可中断锁等候的一些特性。此外，它还提供了在激烈争用情况下更佳的性能。（换句话说，当许多线程都想访问共享资源时，JVM 可以花更少的时候来调度线程，
          把更多时间用在执行线程上。）
    reentrant 锁意味着什么呢？简单来说，它有一个与锁相关的获取计数器，如果拥有锁的某个线程再次得到锁，那么获取计数器就加1，然后锁需要被释放两次才能获得真正
          释放。这模仿了 synchronized 的语义；如果线程进入由线程已经拥有的监控器保护的 synchronized 块，就允许线程继续进行，当线程退出第二个（或者后续）
          synchronized 块的时候，不释放锁，只有线程退出它进入的监控器保护的第一个 synchronized 块时，才释放锁。
          
 2.	当一个线程进入某个对象的一个synchronized的实例方法后，其它线程是否可进入此对象的其它方法？
 答：A、一个线程在访问一个对象的同步方法时，另一个线程可以同时访问这个对象的非同步方法
    B、 一个线程在访问一个对象的同步方法时，另一个线程不能同时访问这个同步方法。
    
    
3.	synchronized(内部锁)和java.util.concurrent.locks.Lock(显示锁)的异同？
 答：Lock 和 synchronized 有一点明显的区别 —— lock 必须在 finally 块中释放。否则，如果受保护的代码将抛出异常，锁就有可能永远得不到释放！
        这一点区别看起来可能没什么，但是实际上，它极为重要。忘记在 finally 块中释放锁，可能会在程序中留下一个定时炸弹，当有一天炸弹爆炸时，您要花费很大力气
        才有找到源头在哪。而使用同步，JVM 将确保锁会获得自动释放。
      注意: 显示锁是对象级别的锁,而内部锁是类级别的.也就是说Lock锁是跟随对象的,synchronized锁是跟随类的.
                   更简单的说把Lock定义为多线程类的私有属性是起不到资源互斥作用的,  除非是把Lock定义为所有线程的共享变量.
                 
   Lock支持更细粒度的锁控制(读写分离)
   Lock是无阻塞锁(等待状态),synchronized是阻塞锁(阻塞状态)
   Lock可实现公平锁(new ReentrantLock(true)),synchronized只能是非公平锁
   Lock是代码级别的(优化要靠用户自行考虑),synchronized是JVM级别的(优化的可能性更高)     
        
        
        
        
        
4.	说说死锁,以及预防和解决的办法
答：  产生死锁的四个条件
	 口. 互斥条件:一个资源每次只能被一个线程使用
	 口. 资源独占条件:一个线程因请求资源而阻塞时,对已获得的资源保持不放
	 口. 不剥夺条件:线程已获得的资源在未使用完之前,不能强行剥夺
	 口. 循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系
	 
	只有满足了上述四个条件　才会产生死锁,所以要解决死锁 可以从这四方面入手.
	比如: A 避免或减少资源共享--> 一个资源被多个线程共享,若采用了同步机制,则产生死锁的可能性很大
	     B 使用自旋锁 Lock.tryLock(2,TimeUnit.SECONDS); // 立刻获取锁,或2秒等待锁资源
	     C 按照顺序加锁是一种有效的死锁预防机制。但是，这种方式需要你事先知道所有可能会用到的锁(注：并对这些锁做适当的排序)，但总有些时候是无法预知的。
	     D 设置一个超时时限 若一个线程没有在给定的时限内成功获得所有需要的锁，则会进行回退并释放所有已经获得的锁，然后等待一段随机的时间再重试 此方法也有不合理之处
	     E 死锁检测是一个更好的死锁预防机制，它主要是针对那些不可能实现按序加锁并且锁超时也不可行的场景。
	     F 给线程设置优先级, 不过一般不介意这样做,而且就算是这样做了也不能保证一定能够按照优先级顺序执行 线程的优先级只是设置获取cpu的机会更多 
	                并不能确保优先级高 一定会先执行
	
        
        
        
        
##############--并发框架--###################

1.	SynchronizedMap和ConcurrentHashMap有什么区别？
答：java5中新增了ConcurrentMap接口和它的一个实现类ConcurrentHashMap。ConcurrentHashMap提供了和Hashtable以及SynchronizedMap中所不同的锁机制。
	比起synchronizedMap来，它提供了好得多的并发性。多个读操作几乎总可以并发地执行，同时进行的读和写操作通常也能并发地执行，而同时进行的写操作仍然可以不时
	地并发进行（相关的类也提供了类似的多个读线程的并发性，但是，只允许有一个活动的写线程）。Hashtable中采用的锁机制是一次锁住整个hash表，从而同一时刻只能由一个
	线程对其进行操作；而ConcurrentHashMap中则是一次锁住一个桶。ConcurrentHashMap默认将hash表分为16个桶，诸如get,put,remove等常用操作只锁当前需要用到的桶。
	这样，原来只能一个线程进入，现在却能同时有16个写线程执行，并发性能的提升是显而易见的。前面说到的16个线程指的是写线程，而读操作大部分时候都不需要用到锁。
	只有在size等操作时才需要锁住整个hash表。
        在迭代方面，ConcurrentHashMap使用了一种不同的迭代方式。在这种迭代方式中，当iterator被创建后集合再发生改变就不再是抛出ConcurrentModificationException，
        取而代之的是在改变时new新的数据从而不影响原有的数据 ，iterator完成后再将头指针替换为新的数据 ，这样iterator线程可以使用原来老的数据，而写线程也可以并发的
        完成改变。
        
        
2.	CopyOnWriteArrayList可以用于什么应用场景？
  答：CopyOnWriteArrayList(免锁容器)的好处之一是当多个迭代器同时遍历和修改这个列表时，不会抛出ConcurrentModificationException。在CopyOnWriteArrayList中，
         写入将导致创建整个底层数组的副本，而源数组将保留在原地，使得复制的数组在被修改时，读取操作可以安全地执行。
         
         



##############--线程安全--#################
1.	什么叫线程安全？servlet是线程安全吗?
 答：如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，
         就是线程安全的。 或者说:一个类或者程序所提供的接口对于线程来说是原子操作或者多个线程之间的切换不会导致该接口的执行结果存在二义性,也就是说我们不用考虑同步的问题。
    servlet不是线程安全的，每个servlet都只被实例化一次，每个调用都是servlet的同一个实例，并且对类变量没有线程安全，数据量大的时候容易照成异常。
    
    
    
    
2.	volatile有什么用？能否用一句话说明下volatile的应用场景？
volatile不能保证数据是同步的,只能保证线程获到最新值  
答：Volatile 变量具有 synchronized 的可见性特性，但是不具备原子特性。可以被看作是一种 “程度较轻的 synchronized”；与 synchronized 块相比，volatile 变量所需的编码较少，并且运行时开销也较少，但是它所能实现的功能也仅是 synchronized 的一部分。
          您只能在有限的一些情形下使用 volatile 变量替代锁。要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件：
                          A. 对变量的写操作不依赖于当前值;或者能够确保只有单一的线程修改变量的值。
                          B. 该变量没有包含在具有其他变量的不变式中;而且访问变量时,没有其他的原因需要加锁。  

                          
                          
                          
                          
























                         
###########--其他--#############
只有满足如下状态,一个对象才是不可变的:
 它的状态不能在创建后在被修改
 所有域都是final类型;并且他被正确创建(创建期间没有发生this引用的逸出)                          